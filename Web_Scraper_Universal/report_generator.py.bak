#!/usr/bin/env python3
"""
Automated Report Generation System
Creates comprehensive reports from various data sources
"""

import json
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import matplotlib.pyplot as plt
import pandas as pd
from pathlib import Path
import os

class ReportGenerator:
    def __init__(self):
        self.reports_dir = "/Users/daniel/Documents/Code/Python/9.25/reports"
        self.charts_dir = "/Users/daniel/Documents/Code/Python/9.25/charts"
        self.ensure_directories()
        
    def ensure_directories(self):
        """Create necessary directories"""
        Path(self.reports_dir).mkdir(parents=True, exist_ok=True)
        Path(self.charts_dir).mkdir(parents=True, exist_ok=True)
        
    def generate_fitness_progress_report(self) -> Dict:
        """Generate comprehensive fitness progress report"""
        report = {
            'report_type': 'fitness_progress',
            'generated_date': datetime.now().isoformat(),
            'period': 'last_30_days',
            'data_sources': ['workout_logs', 'body_measurements', 'goals'],
            'summary': {}
        }
        
        # Simulate workout data (in real implementation, this would come from your databases)
        workout_data = self._simulate_workout_data()
        measurements_data = self._simulate_measurements_data()
        
        # Workout summary
        report['summary']['workouts'] = {
            'total_workouts': len(workout_data),
            'avg_workouts_per_week': len(workout_data) / 4.3,  # ~30 days / 7
            'total_workout_time': sum(w['duration'] for w in workout_data),
            'most_frequent_type': self._get_most_frequent(workout_data, 'type'),
            'consistency_score': self._calculate_consistency_score(workout_data)
        }
        
        # Body composition trends
        if measurements_data:
            latest = measurements_data[-1]
            first = measurements_data[0]
            
            report['summary']['body_composition'] = {
                'current_weight': latest['weight'],
                'weight_change': latest['weight'] - first['weight'],
                'current_body_fat': latest.get('body_fat', 0),
                'body_fat_change': latest.get('body_fat', 0) - first.get('body_fat', 0),
                'measurement_frequency': len(measurements_data)
            }
        
        # Progress towards goals
        report['summary']['goals'] = {
            'active_fitness_goals': 3,  # Simulated
            'completed_this_month': 1,
            'on_track_goals': 2,
            'behind_schedule': 0
        }
        
        # Recommendations
        report['recommendations'] = self._generate_fitness_recommendations(report['summary'])
        
        # Create charts
        chart_files = self._create_fitness_charts(workout_data, measurements_data)
        report['charts'] = chart_files
        
        return report
    
    def _simulate_workout_data(self) -> List[Dict]:
        """Simulate workout data for the last 30 days"""
        workouts = []
        start_date = datetime.now() - timedelta(days=30)
        
        workout_types = ['Strength Training', 'Cardio', 'CrossFit', 'Yoga']
        
        for i in range(20):  # 20 workouts in 30 days
            workout_date = start_date + timedelta(days=i*1.5)
            workouts.append({
                'date': workout_date.strftime('%Y-%m-%d'),
                'type': workout_types[i % len(workout_types)],
                'duration': 45 + (i % 3) * 15,  # 45-75 minutes
                'intensity': ['Low', 'Medium', 'High'][i % 3],
                'exercises_completed': 4 + (i % 3),
                'calories_burned': 300 + (i % 4) * 100
            })
        
        return workouts
    
    def _simulate_measurements_data(self) -> List[Dict]:
        """Simulate body measurement data"""
        measurements = []
        start_date = datetime.now() - timedelta(days=30)
        base_weight = 175.0
        
        for i in range(5):  # Weekly measurements
            measure_date = start_date + timedelta(days=i*7)
            measurements.append({
                'date': measure_date.strftime('%Y-%m-%d'),
                'weight': base_weight + (i * 0.5) + (i % 2) * 0.3,  # Slight upward trend
                'body_fat': 15.0 - (i * 0.2),  # Slight decrease
                'muscle_mass': 145.0 + (i * 0.3),  # Slight increase
                'measurements': {
                    'chest': 42.0 + (i * 0.1),
                    'waist': 32.0 - (i * 0.1),
                    'arms': 15.5 + (i * 0.05),
                    'thighs': 24.0 + (i * 0.1)
                }
            })
        
        return measurements
    
    def _get_most_frequent(self, data: List[Dict], key: str) -> str:
        """Get most frequent value for a key in data"""
        values = [item[key] for item in data]
        return max(set(values), key=values.count)
    
    def _calculate_consistency_score(self, workout_data: List[Dict]) -> int:
        """Calculate workout consistency score (0-100)"""
        if not workout_data:
            return 0
        
        # Score based on frequency and distribution
        total_days = 30
        workout_days = len(set(w['date'] for w in workout_data))
        frequency_score = min((workout_days / (total_days / 7)) * 20, 70)  # Max 70 for frequency
        
        # Distribution score (avoiding long gaps)
        dates = [datetime.strptime(w['date'], '%Y-%m-%d') for w in workout_data]
        dates.sort()
        
        gaps = [(dates[i+1] - dates[i]).days for i in range(len(dates)-1)]
        avg_gap = sum(gaps) / len(gaps) if gaps else 0
        distribution_score = max(30 - avg_gap * 3, 0)  # Max 30 for distribution
        
        return min(int(frequency_score + distribution_score), 100)
    
    def _generate_fitness_recommendations(self, summary: Dict) -> List[str]:
        """Generate fitness recommendations based on data"""
        recommendations = []
        
        workout_summary = summary.get('workouts', {})
        consistency = workout_summary.get('consistency_score', 0)
        
        if consistency < 70:
            recommendations.append("Improve workout consistency - aim for 4-5 workouts per week")
        
        avg_per_week = workout_summary.get('avg_workouts_per_week', 0)
        if avg_per_week < 3:
            recommendations.append("Increase workout frequency to at least 3 times per week")
        elif avg_per_week > 6:
            recommendations.append("Consider adding more rest days to prevent overtraining")
        
        body_comp = summary.get('body_composition', {})
        weight_change = body_comp.get('weight_change', 0)
        
        if weight_change > 2:
            recommendations.append("Weight gain is on track for lean bulk - monitor body fat levels")
        elif weight_change < 0.5:
            recommendations.append("Consider increasing caloric intake for muscle gain")
        
        if body_comp.get('measurement_frequency', 0) < 4:
            recommendations.append("Increase measurement frequency to weekly for better tracking")
        
        if not recommendations:
            recommendations.append("Great progress! Continue current routine and monitor trends")
        
        return recommendations
    
    def _create_fitness_charts(self, workout_data: List[Dict], measurements_data: List[Dict]) -> List[str]:
        """Create charts for fitness data"""
        chart_files = []
        
        # Workout frequency chart
        plt.figure(figsize=(10, 6))
        dates = [datetime.strptime(w['date'], '%Y-%m-%d') for w in workout_data]
        types = [w['type'] for w in workout_data]
        
        # Count workouts by week
        weeks = {}
        for date in dates:
            week = date.strftime('%Y-W%U')
            weeks[week] = weeks.get(week, 0) + 1
        
        plt.bar(range(len(weeks)), list(weeks.values()))
        plt.title('Workouts per Week')
        plt.xlabel('Week')
        plt.ylabel('Number of Workouts')
        plt.xticks(range(len(weeks)), [w.split('-W')[1] for w in weeks.keys()])
        
        chart_file = os.path.join(self.charts_dir, 'workout_frequency.png')
        plt.savefig(chart_file)
        plt.close()
        chart_files.append(chart_file)
        
        # Body weight trend chart
        if measurements_data:
            plt.figure(figsize=(10, 6))
            measure_dates = [datetime.strptime(m['date'], '%Y-%m-%d') for m in measurements_data]
            weights = [m['weight'] for m in measurements_data]
            
            plt.plot(measure_dates, weights, marker='o', linewidth=2, markersize=8)
            plt.title('Body Weight Trend')
            plt.xlabel('Date')
            plt.ylabel('Weight (lbs)')
            plt.grid(True, alpha=0.3)
            
            chart_file = os.path.join(self.charts_dir, 'weight_trend.png')
            plt.savefig(chart_file)
            plt.close()
            chart_files.append(chart_file)
        
        return chart_files
    
    def generate_productivity_report(self) -> Dict:
        """Generate productivity and goal progress report"""
        report = {
            'report_type': 'productivity',
            'generated_date': datetime.now().isoformat(),
            'period': 'last_30_days',
            'summary': {}
        }
        
        # Simulate goal and task data
        goals_data = self._simulate_goals_data()
        tasks_data = self._simulate_tasks_data()
        
        # Goals summary
        report['summary']['goals'] = {
            'total_active_goals': len([g for g in goals_data if g['status'] == 'active']),
            'completed_this_month': len([g for g in goals_data if g['status'] == 'completed']),
            'average_progress': sum(g['progress'] for g in goals_data) / len(goals_data),
            'on_schedule': len([g for g in goals_data if g['on_schedule']]),
            'overdue': len([g for g in goals_data if not g['on_schedule'] and g['status'] == 'active'])
        }
        
        # Tasks summary
        report['summary']['tasks'] = {
            'total_completed': len([t for t in tasks_data if t['status'] == 'completed']),
            'average_completion_time': self._calculate_avg_completion_time(tasks_data),
            'most_productive_day': self._get_most_productive_day(tasks_data),
            'task_categories': self._get_task_category_breakdown(tasks_data)
        }
        
        # Time management insights
        report['summary']['time_management'] = {
            'estimated_vs_actual': self._analyze_time_estimates(tasks_data),
            'peak_productivity_hours': '9 AM - 11 AM',  # Simulated
            'weekly_focus_time': 25.5  # hours, simulated
        }
        
        # Recommendations
        report['recommendations'] = self._generate_productivity_recommendations(report['summary'])
        
        return report
    
    def _simulate_goals_data(self) -> List[Dict]:
        """Simulate goals data"""
        return [
            {
                'id': 1,
                'title': 'Complete Lean Bulk Program',
                'status': 'active',
                'progress': 45.0,
                'target_date': '2026-01-15',
                'on_schedule': True,
                'category': 'fitness'
            },
            {
                'id': 2,
                'title': 'Organize Digital Files',
                'status': 'active',
                'progress': 75.0,
                'target_date': '2025-11-01',
                'on_schedule': True,
                'category': 'productivity'
            },
            {
                'id': 3,
                'title': 'Learn Advanced Python',
                'status': 'completed',
                'progress': 100.0,
                'target_date': '2025-10-01',
                'on_schedule': True,
                'category': 'learning'
            }
        ]
    
    def _simulate_tasks_data(self) -> List[Dict]:
        """Simulate tasks data"""
        tasks = []
        categories = ['fitness', 'work', 'personal', 'learning']
        statuses = ['completed', 'in_progress', 'pending']
        
        for i in range(50):
            task_date = datetime.now() - timedelta(days=i//2)
            tasks.append({
                'id': i,
                'title': f'Task {i}',
                'category': categories[i % len(categories)],
                'status': statuses[i % len(statuses)],
                'estimated_hours': 1 + (i % 4),
                'actual_hours': 1.2 + (i % 4) + (i % 3) * 0.3,
                'created_date': task_date.strftime('%Y-%m-%d'),
                'completed_date': task_date.strftime('%Y-%m-%d') if i % 3 == 0 else None
            })
        
        return tasks
    
    def _calculate_avg_completion_time(self, tasks_data: List[Dict]) -> float:
        """Calculate average task completion time"""
        completed_tasks = [t for t in tasks_data if t['status'] == 'completed' and t['actual_hours']]
        if not completed_tasks:
            return 0
        return sum(t['actual_hours'] for t in completed_tasks) / len(completed_tasks)
    
    def _get_most_productive_day(self, tasks_data: List[Dict]) -> str:
        """Determine most productive day of the week"""
        completed_by_day = {}
        for task in tasks_data:
            if task['status'] == 'completed' and task['completed_date']:
                date = datetime.strptime(task['completed_date'], '%Y-%m-%d')
                day = date.strftime('%A')
                completed_by_day[day] = completed_by_day.get(day, 0) + 1
        
        if not completed_by_day:
            return 'Unknown'
        return max(completed_by_day, key=completed_by_day.get)
    
    def _get_task_category_breakdown(self, tasks_data: List[Dict]) -> Dict:
        """Get breakdown of tasks by category"""
        breakdown = {}
        for task in tasks_data:
            category = task['category']
            breakdown[category] = breakdown.get(category, 0) + 1
        return breakdown
    
    def _analyze_time_estimates(self, tasks_data: List[Dict]) -> Dict:
        """Analyze accuracy of time estimates"""
        completed_tasks = [t for t in tasks_data if t['status'] == 'completed' and t['actual_hours']]
        if not completed_tasks:
            return {'accuracy': 0, 'avg_overrun': 0}
        
        total_estimated = sum(t['estimated_hours'] for t in completed_tasks)
        total_actual = sum(t['actual_hours'] for t in completed_tasks)
        
        accuracy = (total_estimated / total_actual) * 100 if total_actual > 0 else 0
        avg_overrun = (total_actual - total_estimated) / len(completed_tasks)
        
        return {
            'accuracy': round(accuracy, 1),
            'avg_overrun_hours': round(avg_overrun, 2)
        }
    
    def _generate_productivity_recommendations(self, summary: Dict) -> List[str]:
        """Generate productivity recommendations"""
        recommendations = []
        
        goals = summary.get('goals', {})
        if goals.get('overdue', 0) > 0:
            recommendations.append(f"Review {goals['overdue']} overdue goals and adjust timelines")
        
        if goals.get('average_progress', 0) < 50:
            recommendations.append("Consider breaking down goals into smaller, actionable tasks")
        
        time_mgmt = summary.get('time_management', {})
        estimates = time_mgmt.get('estimated_vs_actual', {})
        
        if estimates.get('accuracy', 100) < 80:
            recommendations.append("Improve time estimation accuracy by tracking actual vs estimated time")
        
        if estimates.get('avg_overrun_hours', 0) > 1:
            recommendations.append("Add buffer time to task estimates to account for overruns")
        
        tasks = summary.get('tasks', {})
        if tasks.get('total_completed', 0) < 20:
            recommendations.append("Increase task completion rate by focusing on smaller, achievable tasks")
        
        if not recommendations:
            recommendations.append("Excellent productivity! Continue current practices")
        
        return recommendations
    
    def generate_financial_overview(self) -> Dict:
        """Generate financial overview report based on budget documents"""
        report = {
            'report_type': 'financial_overview',
            'generated_date': datetime.now().isoformat(),
            'period': 'current_month',
            'summary': {}
        }
        
        # Simulate financial data (would extract from your budget PDFs)
        financial_data = {
            'income': {
                'primary': 4500.00,
                'secondary': 800.00,
                'total': 5300.00
            },
            'expenses': {
                'fixed': {
                    'rent': 1200.00,
                    'utilities': 150.00,
                    'insurance': 200.00,
                    'total': 1550.00
                },
                'variable': {
                    'food': 600.00,
                    'fitness': 150.00,
                    'entertainment': 200.00,
                    'miscellaneous': 180.00,
                    'total': 1130.00
                },
                'total': 2680.00
            },
            'savings': 2620.00,
            'investments': {
                'retirement': 500.00,
                'personal': 300.00,
                'total': 800.00
            }
        }
        
        report['summary'] = financial_data
        
        # Calculate key metrics
        report['metrics'] = {
            'savings_rate': (financial_data['savings'] / financial_data['income']['total']) * 100,
            'expense_ratio': (financial_data['expenses']['total'] / financial_data['income']['total']) * 100,
            'investment_rate': (financial_data['investments']['total'] / financial_data['income']['total']) * 100,
            'emergency_fund_months': 6.5  # Simulated
        }
        
        # Financial health score
        report['health_score'] = self._calculate_financial_health_score(report['metrics'])
        
        # Recommendations
        report['recommendations'] = self._generate_financial_recommendations(report['metrics'])
        
        return report
    
    def _calculate_financial_health_score(self, metrics: Dict) -> int:
        """Calculate financial health score (0-100)"""
        score = 0
        
        # Savings rate (30 points max)
        savings_rate = metrics.get('savings_rate', 0)
        if savings_rate >= 20:
            score += 30
        elif savings_rate >= 15:
            score += 25
        elif savings_rate >= 10:
            score += 20
        elif savings_rate >= 5:
            score += 15
        
        # Expense ratio (25 points max)
        expense_ratio = metrics.get('expense_ratio', 100)
        if expense_ratio <= 60:
            score += 25
        elif expense_ratio <= 70:
            score += 20
        elif expense_ratio <= 80:
            score += 15
        elif expense_ratio <= 90:
            score += 10
        
        # Investment rate (25 points max)
        investment_rate = metrics.get('investment_rate', 0)
        if investment_rate >= 15:
            score += 25
        elif investment_rate >= 10:
            score += 20
        elif investment_rate >= 5:
            score += 15
        
        # Emergency fund (20 points max)
        emergency_months = metrics.get('emergency_fund_months', 0)
        if emergency_months >= 6:
            score += 20
        elif emergency_months >= 4:
            score += 15
        elif emergency_months >= 2:
            score += 10
        
        return min(score, 100)
    
    def _generate_financial_recommendations(self, metrics: Dict) -> List[str]:
        """Generate financial recommendations"""
        recommendations = []
        
        savings_rate = metrics.get('savings_rate', 0)
        if savings_rate < 10:
            recommendations.append("Increase savings rate to at least 10% of income")
        elif savings_rate < 20:
            recommendations.append("Great start! Aim to increase savings rate to 20%")
        
        investment_rate = metrics.get('investment_rate', 0)
        if investment_rate < 10:
            recommendations.append("Consider increasing investment rate for long-term wealth building")
        
        emergency_months = metrics.get('emergency_fund_months', 0)
        if emergency_months < 3:
            recommendations.append("Build emergency fund to cover 3-6 months of expenses")
        elif emergency_months < 6:
            recommendations.append("Continue building emergency fund to 6 months of expenses")
        
        expense_ratio = metrics.get('expense_ratio', 0)
        if expense_ratio > 80:
            recommendations.append("Review expenses and identify areas to reduce spending")
        
        if not recommendations:
            recommendations.append("Excellent financial health! Consider advanced investment strategies")
        
        return recommendations
    
    def generate_comprehensive_report(self) -> Dict:
        """Generate a comprehensive report combining all areas"""
        comprehensive_report = {
            'report_type': 'comprehensive',
            'generated_date': datetime.now().isoformat(),
            'period': 'last_30_days',
            'sections': {}
        }
        
        # Generate individual reports
        fitness_report = self.generate_fitness_progress_report()
        productivity_report = self.generate_productivity_report()
        financial_report = self.generate_financial_overview()
        
        comprehensive_report['sections']['fitness'] = fitness_report
        comprehensive_report['sections']['productivity'] = productivity_report
        comprehensive_report['sections']['financial'] = financial_report
        
        # Overall summary
        comprehensive_report['overall_summary'] = {
            'total_active_goals': productivity_report['summary']['goals']['total_active_goals'],
            'fitness_consistency': fitness_report['summary']['workouts']['consistency_score'],
            'financial_health': financial_report['health_score'],
            'productivity_score': self._calculate_productivity_score(productivity_report),
            'key_achievements': self._extract_key_achievements(fitness_report, productivity_report, financial_report)
        }
        
        # Top priorities for next period
        comprehensive_report['next_period_priorities'] = self._generate_next_period_priorities(
            fitness_report, productivity_report, financial_report
        )
        
        return comprehensive_report
    
    def _calculate_productivity_score(self, productivity_report: Dict) -> int:
        """Calculate overall productivity score"""
        goals = productivity_report['summary']['goals']
        avg_progress = goals.get('average_progress', 0)
        completion_rate = goals.get('completed_this_month', 0) / max(goals.get('total_active_goals', 1), 1)
        
        return min(int(avg_progress * 0.7 + completion_rate * 30), 100)
    
    def _extract_key_achievements(self, fitness_report: Dict, productivity_report: Dict, financial_report: Dict) -> List[str]:
        """Extract key achievements across all areas"""
        achievements = []
        
        # Fitness achievements
        workouts = fitness_report['summary']['workouts']
        if workouts['consistency_score'] >= 80:
            achievements.append(f"Maintained {workouts['consistency_score']}% workout consistency")
        
        if workouts['total_workouts'] >= 20:
            achievements.append(f"Completed {workouts['total_workouts']} workouts this month")
        
        # Productivity achievements
        goals = productivity_report['summary']['goals']
        if goals['completed_this_month'] > 0:
            achievements.append(f"Completed {goals['completed_this_month']} major goals")
        
        # Financial achievements
        financial_health = financial_report['health_score']
        if financial_health >= 80:
            achievements.append(f"Maintained excellent financial health (score: {financial_health})")
        
        return achievements
    
    def _generate_next_period_priorities(self, fitness_report: Dict, productivity_report: Dict, financial_report: Dict) -> List[str]:
        """Generate priorities for the next period"""
        priorities = []
        
        # Combine recommendations from all reports
        all_recommendations = (
            fitness_report.get('recommendations', []) +
            productivity_report.get('recommendations', []) +
            financial_report.get('recommendations', [])
        )
        
        # Select top 3-5 priorities
        priorities = all_recommendations[:5]
        
        return priorities
    
    def save_report(self, report: Dict, filename: str = None):
        """Save report to file"""
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{report['report_type']}_report_{timestamp}.json"
        
        filepath = os.path.join(self.reports_dir, filename)
        with open(filepath, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"Report saved to: {filepath}")
        return filepath

def main():
    generator = ReportGenerator()
    
    # Generate individual reports
    print("Generating fitness progress report...")
    fitness_report = generator.generate_fitness_progress_report()
    generator.save_report(fitness_report, "fitness_report.json")
    
    print("Generating productivity report...")
    productivity_report = generator.generate_productivity_report()
    generator.save_report(productivity_report, "productivity_report.json")
    
    print("Generating financial overview...")
    financial_report = generator.generate_financial_overview()
    generator.save_report(financial_report, "financial_report.json")
    
    print("Generating comprehensive report...")
    comprehensive_report = generator.generate_comprehensive_report()
    generator.save_report(comprehensive_report, "comprehensive_report.json")
    
    # Print summary
    print(f"\n=== Report Summary ===")
    print(f"Fitness Consistency: {fitness_report['summary']['workouts']['consistency_score']}%")
    print(f"Financial Health Score: {financial_report['health_score']}/100")
    print(f"Active Goals: {productivity_report['summary']['goals']['total_active_goals']}")
    
    print(f"\nKey Achievements:")
    for achievement in comprehensive_report['overall_summary']['key_achievements']:
        print(f"â€¢ {achievement}")
    
    print(f"\nReports directory: {generator.reports_dir}")
    print(f"Charts directory: {generator.charts_dir}")

if __name__ == "__main__":
    main()